<h1>hello me from local</h1>
<h1>da para passar att por aqui tambem, bem legal</h1>
<h1>ENVIANDO INFOS PARA O NOVO FOLDER</h1>


<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <h1>O resultado de dar merge com duas versões que estão sendo atualizadas simultaneamente linha 17 é da branch
        main e 21 da function_new</h1>
    <script src="new_func.js" type="module" defer></script>
    <h2>elemento aleatório para testar a tag, ou melhor dizendo o versionamento do repo</h2>
</body>

</html>
<clone>
    git clone url .
    o ponto pega todos os files dento o repo, commando que eu estava procurando a meses...
</clone>
Nota: todo o conteúdo é para estar no git-prod no workspace, mas no repo só existe 1, o git practice...

vamos dar merge no ambiente de prod

<branch>
    para dar merge em branch vc vai na main git checkout main >> git merge <branch>
        ou seja, trabalha nas branch secundaria e da merge na main, dai tudo que foi atualizado nas branch secundaria
        vem
        para a main

        vamos aplicar isso na onFrete pro hj, vou usar a branch dev e atualizar para o novo código da site-without-https
        e
        quando estiver rodando o fino eu do merge
        com a branch de prod, ou talvez esse seja o plano para amanha, vamos ver.
        como podemos ver nesse exemplo, criei uma nova branch new_func e nela criei uma nova func, dai dei commit -a -m
        e
        então fui para a main e na main dei merge com a new_func

        na linha abaixo vai ter coisas novas

        vou testar para ver se as infos se sobrescreve no merge

        Bom, branch tem mais ainda...
        ex: Imagina o cenário onde eu inicio um workspace novo, dai preciso dar um pull na url, dei esse pull linkei com
        a url git remote add origin url e o que acontece? Vou estar em uma branch zerada, normalmente a master, dai eu
        eo posso dar o push nesse novo workspace para o repo que dei pull só que ao fazer isso a branch desse novo
        workspace vai estar como master, e o push vai inserir esse conteúdo como master.
        depois disso eu posso pegar as branch que esta armazenada no repo com o git fetch -a, e com isso tenho acesso a
        todas as branch nesse workspace novo, como por exemplo a main
    </branch>

    <fetch>
        Suponhamos que iniciei um workflow novo, dai dei pull em um repo existente, nesse novo workspace preciso ter
        acesso as branch originais do repo
        dai então uso o git fetch -a e pego todas as branch.
        mas o processo de iniciar um work flow normalmente é assim
        git pull url branch
        git remote add origin url
        git fetch -a
        git add .
        git commit -a -m ''
        git push
        dai voce cria a branch master nesse caso...
        mas da para trocar de branch antes, ja que deu o fetch
    </fetch>

    <stash>
        git stash armazena o codigo em cache que ainda não foi commitado, então da para da um "roll back" para uma
        versão antes do
        commit

        git stash drop num deleta a stash especificada da stash list
        git stash clear limpa tudo
    </stash>


    <tags>
        e um dos mais importante para o repo são as tags git tag -a v1.0 -m "primeira versão" um exemplo

        estamos na versão 5

        e aqui somente na versão 6

        git checkout tagOption
        esse comando possibilita a navegação entre as versões ex: git checkout v1.0
        dai da para commitar somente 1 tag ou todas se quiser git push origin tagOptions
    </tags>

    <remote>
        git remote add origin url
        esse cara adiciona a origin do repo em tem local workspace. ex: dei pull em um repo para trabalhar em um
        workspace diferente, dai quando for commitar preciso linkar com a url do repo
        git remote -v
        tu ve a origin
        o -v representa o verbose
    </remote>